# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_GNN_vs_SA_for_Max_Cut.ipynb.

# %% auto 0
__all__ = ['inner_solve_with_gnn', 'solve_with_gnn', 'solve_with_annealing']

# %% ../01_GNN_vs_SA_for_Max_Cut.ipynb 6
from gnn_for_co.core import (
    create_train_state,
    train_step,
    get_classification,
    create_Q_matrix,
    create_max_cut_model,
    create_mis_model,
)

import jax
import jax.numpy as jnp
import numpy as np
import networkx as nx
import openjij as oj
import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from tqdm.notebook import trange, tqdm

sns.set_theme()

# %% ../01_GNN_vs_SA_for_Max_Cut.ipynb 16
def inner_solve_with_gnn(
    G,
    embedding_size,
    hidden_size,
    learning_rate,
    epochs,
    dropout_rate,
    seed=2023,
    verbose=False,
    is_max_cut=True,
):
    A = jnp.array(nx.to_numpy_array(G))
    Q = create_Q_matrix(G, is_max_cut=is_max_cut)

    rng = jax.random.PRNGKey(seed)
    rng, init_rng = jax.random.split(rng)
    rng, embed_rng = jax.random.split(rng)
    state = create_train_state(
        G.number_of_nodes(),
        embedding_size,
        hidden_size,
        init_rng,
        learning_rate,
        dropout_frac=0.01,
    )
    node_embeddings = jax.random.uniform(embed_rng, [G.number_of_nodes(), embedding_size])

    for epoch in trange(1, epochs + 1, disable=not verbose):
        rng, dropout_rng = jax.random.split(rng)
        state, metrics = train_step(
            state=state,
            node_embeddings=node_embeddings,
            adj_matrix=A,
            q_matrix=Q,
            dropout_rng=dropout_rng,
        )

        if epoch % 25 == 0 and verbose:
            print("train epoch: %d, cost: %.2f" % (epoch, metrics["energy"]))

    classification = np.array(
        get_classification(state.apply_fn, state.params, node_embeddings, A)
    )
    probs = state.apply_fn({"params": state.params}, node_embeddings, A)
    solution = {f"X[{i}]": classification[i] for i in range(G.number_of_nodes())}
    last_energy = metrics["energy"]

    return {
        "classification": classification,
        "probs": probs,
        "energy": last_energy,
        "solution": solution,
    }


def solve_with_gnn(
    G,
    embedding_size,
    hidden_size,
    learning_rate,
    epochs,
    dropout_rate,
    seed=2023,
    verbose=False,
    shots=5,
    is_max_cut=True,
):
    lower_bound = -G.number_of_nodes() / 10.0

    for k in range(shots):
        solution = inner_solve_with_gnn(
            G,
            embedding_size,
            hidden_size,
            learning_rate,
            epochs,
            dropout_rate,
            seed + (k + 1) ** 3,
            verbose,
            is_max_cut,
        )

        if solution["energy"] <= lower_bound:
            break

    return solution

# %% ../01_GNN_vs_SA_for_Max_Cut.ipynb 17
def solve_with_annealing(G, num_reads, is_max_cut=True):
    sampler = oj.SASampler()

    if is_max_cut:
        model = create_max_cut_model(G)
    else:
        model = create_mis_model(G)

    qubo_dict, offset = model.to_qubo()

    response = sampler.sample_qubo(qubo_dict, num_reads=num_reads)

    return {
        "sample": response.first.sample,
        "energy": response.first.energy,
        "model": model,
    }
